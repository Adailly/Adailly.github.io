<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Adailly blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Adailly blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Adailly blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Adailly blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Adailly blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录这件小事...</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/iOS系统加密函数详解：MD5、SHA、DES/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adailly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adailly blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/iOS系统加密函数详解：MD5、SHA、DES/" itemprop="url">iOS系统加密函数详解：MD5、SHA、DES</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T10:40:12+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="iOS系统加密函数详解"><a href="#iOS系统加密函数详解" class="headerlink" title="iOS系统加密函数详解"></a>iOS系统加密函数详解</h2><h3 id="加密的种类"><a href="#加密的种类" class="headerlink" title="加密的种类"></a>加密的种类</h3><ul>
<li>单向加密<br>通过对数据进行摘要计算生成密文，密文不可逆推还原，如：MD5、SHA、Base64</li>
<li><p>双向加密<br>与单向加密相反，可以把密文逆推还原成明文，双向加密又分为对称加密和非对称加密</p>
<ul>
<li>对称加密<br>数据使用者必须拥有相同的秘钥才可以进行加密解密。如：DES、3DES、AES、IDEA、RC4、RC5</li>
<li>非对称加密<br>相对对称加密，无需拥有同一组密钥。非对称加密是一种“信息公开的密钥交换协议”。<br>非对称加密需要公开密钥和私有密钥两组密钥，把公开的密钥为公钥，不公开的密钥为私钥。公钥和私钥是配对起来的，使用公钥进行数据加密，只有对应的私钥才能解密，这两个密钥是数学相关的，如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个密钥的安全。<br>如：RSA、DSA </li>
</ul>
</li>
<li><p>iOS中系统封装好的加密函数有：<code>MD5</code>、<code>SHA1~SHA512</code>、<code>DES</code>等，使用系统加密函数，需要先引入头文件<code>&lt;CommonCrypto/&gt;</code>，其下有针对不同加密模式的分类，注意选择对应的模式。</p>
</li>
<li>单项加密引入：<code>#import &lt;CommonCrypto/CommonDigest.h&gt;</code></li>
<li>双向加密引入：<code>#import &lt;CommonCrypto/CommonCrypto.h&gt;</code></li>
</ul>
<h3 id="iOS系统加密函数的用法"><a href="#iOS系统加密函数的用法" class="headerlink" title="iOS系统加密函数的用法"></a>iOS系统加密函数的用法</h3><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p><code>MD5</code>可以产生一个128位的散列值。<code>8bit = 1byte</code>，故生成16字节的散列值。<br>16进制两个字符等于一个字节，故生成的16进制密文为32个字符。<br><code>1byte</code>可以表示的数字范围为<code>0~255</code>，刚好等于<code>2个16进制字符的范围</code>。</p>
<ul>
<li>需要用到的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/** 获取字符串编码后的长度</span><br><span class="line"> * 也可以通过strlen([string UTF8String])获取</span><br><span class="line"> */</span><br><span class="line">- (unsigned int)stringLength:(NSString *)string &#123;</span><br><span class="line">    return (unsigned int)[string lengthOfBytesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 将加密后的字符转为16进制</span><br><span class="line"></span><br><span class="line"> @param data 生成的密文数据</span><br><span class="line"> @param length 数据的长度</span><br><span class="line"> @return 16进制的密文</span><br><span class="line"> */</span><br><span class="line">- (NSString *)hexStringWithCipherTextData:(unsigned char *)data length:(unsigned int)length &#123;</span><br><span class="line">    // 开辟length*2的字节空间，16进制中2个字符为一个字节</span><br><span class="line">    NSMutableString *hexStr = [NSMutableString stringWithCapacity:length * 2];</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        [hexStr appendFormat:@&quot;%02x&quot;, data[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return hexStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="MD5示例"><a href="#MD5示例" class="headerlink" title="MD5示例"></a>MD5示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * MD5加密后的密文长度为128bit，即16字节 = 16 * 8，转为16进制为32字符</span><br><span class="line"> * 16进制：2字符为一字节，16 * 2 = 32</span><br><span class="line"> */</span><br><span class="line">/** MD5加密 */</span><br><span class="line">- (NSString *)MD5:(NSString *)string &#123;</span><br><span class="line">	// 系统提供的密文长度：16字节</span><br><span class="line">    unsigned int outPutLength = CC_MD5_DIGEST_LENGTH;</span><br><span class="line">    // 获取明文编码后的长度</span><br><span class="line">    unsigned int inPutLength = [self stringLength:string];</span><br><span class="line">    // 根据密文的长度，创建一个保存密文的数组</span><br><span class="line">    unsigned char outPutData[outPutLength];</span><br><span class="line">    // 调用系统的方法</span><br><span class="line">    /*extern unsigned char *CC_MD5(const void *data, CC_LONG len, unsigned char *md)*/</span><br><span class="line">    CC_MD5([string UTF8String], inPutLength, outPutData);</span><br><span class="line">    // 返回16进制密文</span><br><span class="line">    return [self hexStringWithCipherTextData:outPutData length:outPutLength];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SHA-SHA的调用和MD5类似"><a href="#SHA-SHA的调用和MD5类似" class="headerlink" title="SHA SHA的调用和MD5类似"></a>SHA SHA的调用和MD5类似</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/** SHA加密后的字节大小</span><br><span class="line"> *  CC_SHA1的字节长度20，对应的16进制字符数是20*2</span><br><span class="line"> *  CC_SHA256的字节长度分别是32，对应的16进制字符数是32*2</span><br><span class="line"> *  CC_SHA384的字节长度分别是48，对应的16进制字符数是48*2</span><br><span class="line"> *  CC_SHA512的字节长度分别是64，对应的16进制字符数是64*2</span><br><span class="line"> */</span><br><span class="line">/** SHA1加密 */</span><br><span class="line">- (NSString *)SHA1:(NSString *)string &#123;</span><br><span class="line">    unsigned int outPutLength = CC_SHA1_DIGEST_LENGTH;</span><br><span class="line">    unsigned int inPutLength = [self stringLength:string];</span><br><span class="line">    unsigned char outPutData[outPutLength];</span><br><span class="line">    </span><br><span class="line">    CC_MD5([string UTF8String], inPutLength, outPutData);</span><br><span class="line">    </span><br><span class="line">    return [self hexStringWithCipherTextData:outPutData length:outPutLength];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** SHA256加密 */</span><br><span class="line">- (NSString *)SHA256:(NSString *)string &#123;</span><br><span class="line">    unsigned int outPutLength = CC_SHA256_DIGEST_LENGTH;</span><br><span class="line">    unsigned int inPutLength = [self stringLength:string];</span><br><span class="line">    unsigned char outPutData[outPutLength];</span><br><span class="line">    </span><br><span class="line">    CC_MD5([string UTF8String], inPutLength, outPutData);</span><br><span class="line">    </span><br><span class="line">    return [self hexStringWithCipherTextData:outPutData length:outPutLength];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DES加密"><a href="#DES加密" class="headerlink" title="DES加密"></a>DES加密</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>DES</code>全称为<code>Data Encryption Standard</code>，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。需要注意的是，在某些文献中，作为算法的DES称为数据加密算法（Data Encryption Algorithm,DEA），已与作为标准的DES区分开来.</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>DES设计中使用了分组密码设计的两个原则：</p>
<ul>
<li>混淆（confusion)<br>混淆是使密文的统计特性与密钥的取值之间的关系尽可能复杂化，以使密钥和明文以及密文之间的依赖性对密码分析者来说是无法利用的。</li>
<li><p>扩散(diffusion)<br>扩散的作用就是将每一位明文的影响尽可能迅速地作用到较多的输出密文位中，以便在大量的密文中消除明文的统计结构，并且使每一位密钥的影响尽可能迅速地扩展到较多的密文位中，以防对密钥进行逐段破译。</p>
</li>
<li><p>目的：抗击敌手对密码系统的统计分析。</p>
</li>
</ul>
<h4 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h4><p>DES的加密模式有如下几种：</p>
<ul>
<li><code>DES/CBC/PKCS5Padding</code> 对应的OC模式：<code>kCCOptionPKCS7Padding</code></li>
<li><code>DES/ECB/PKCS5Padding</code> 对应的OC模式：<code>kCCOptionPKCS7Padding | kCCOptionECBMode</code></li>
</ul>
<p><em>每一段的解释如下：</em></p>
<ul>
<li>第一段：加密算法的名称</li>
<li>第二段：分组加密模式，除了CBC和ECB之外，还可以是NONE/CFB/QFB等。最常用的就是CBC和ECB。<br>DES采用分组加密的方式，将明文按8字节(64位)分组分别加密。如果每个组独立处理，则是ECB。<br>CBC的处理方式是先用初始向量iv对第一组加密，再用第一组的密文座位秘钥对第二组加密，然后依次完成整个加密操作。<br>如果明文中有两个分组的内容相同，ECB会得到完全一样的密文，CBC则不会。</li>
<li>第三段：最后一个分组的填充方式。大部分情况下，明文并非刚好64位的倍数。对于最后一个分组，如果长度小于64位，则需要用数据填充至64位。<br>PKCS5Padding是常用的填充方式，如果没有指定，默认的方式就是它。<br>ps：DES的有效秘钥长度是56位，但要求秘钥长度是64位(8字节)。3DES则要求24字节。  </li>
</ul>
<h4 id="加密函数CCCrypt详解"><a href="#加密函数CCCrypt详解" class="headerlink" title="加密函数CCCrypt详解"></a>加密函数CCCrypt详解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CCCryptorStatus CCCrypt(</span><br><span class="line">    CCOperation op,         /* kCCEncrypt, etc. */</span><br><span class="line">    CCAlgorithm alg,        /* kCCAlgorithmAES128, etc. */</span><br><span class="line">    CCOptions options,      /* kCCOptionPKCS7Padding, etc. */</span><br><span class="line">    const void *key,</span><br><span class="line">    size_t keyLength,</span><br><span class="line">    const void *iv,         /* optional initialization vector */</span><br><span class="line">    const void *dataIn,     /* optional per op and alg */</span><br><span class="line">    size_t dataInLength,</span><br><span class="line">    void *dataOut,          /* data RETURNED here */</span><br><span class="line">    size_t dataOutAvailable,</span><br><span class="line">    size_t *dataOutMoved);</span><br></pre></td></tr></table></figure>
<ul>
<li>CCCrypt：函数名</li>
<li>摘要：无状态的, 一次加密或解密的操作。是对这些加密函数的封装：CCCrytorCreate(),CCCryptorUpdate(), CCCryptorFinal(), and CCCryptorRelease()</li>
<li>op：加解密，枚举值：<code>kCCEncrypt</code>，<code>kCCDecrypt</code></li>
<li>alg：算法名称，<code>kCCAlgorithmAES128</code>,<code>kCCAlgorithmAES</code>,<code>kCCAlgorithmDES</code>,<code>kCCAlgorithm3DES</code>,<code>kCCAlgorithmCAST</code>,<code>kCCAlgorithmRC4</code>,<code>kCCAlgorithmRC2</code>, <code>kCCAlgorithmBlowfish</code></li>
<li>options：填充方式，通常是<code>kCCOptionPKCS7Padding</code>，默认分组模式CBC。OC中提供两种模式：<code>kCCOptionPKCS7Padding</code>、<code>kCCOptionECBMode</code></li>
<li>key：秘钥</li>
<li>keyLength：秘钥长度，必须和选择的算法相匹配，不同的算法要求的秘钥长度不一样。可选值如下：<ul>
<li>kCCKeySizeAES128          = 16,</li>
<li>kCCKeySizeAES192          = 24,</li>
<li>kCCKeySizeAES256          = 32,</li>
<li>kCCKeySizeDES             = 8,</li>
<li>kCCKeySize3DES            = 24,</li>
<li>kCCKeySizeMinCAST         = 5,</li>
<li>kCCKeySizeMaxCAST         = 16,</li>
<li>kCCKeySizeMinRC4          = 1,</li>
<li>kCCKeySizeMaxRC4          = 512,</li>
<li>kCCKeySizeMinRC2          = 1,</li>
<li>kCCKeySizeMaxRC2          = 128,</li>
<li>kCCKeySizeMinBlowfish     = 8,</li>
<li>kCCKeySizeMaxBlowfish</li>
</ul>
</li>
<li><p>iv：加密使用的向量参数，CBC模式需要，16字节。ECB模式不需要。<br>原始解释：初始向量，可选类型，用于CBC模式。如果存在，则必须与所选算法的块大小相同。如果选择了CBC模式(由于选项标志中没有任何模式位)，并且没有IV，将使用NULL(所有0)IV。如果使用ECB模式或选择了流密码算法，则忽略此操作。对于声音加密，总是使用随机数据初始化IV。<br>  iv的创建有三种方式：</p>
<ul>
<li><code>const Byte iv[] = {1,2,3,4,5,6,7,8};</code></li>
<li><code>const Byte iv[] = {0,1,2,3,4,5,6,7};</code></li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *testString = key; // 秘钥</span><br><span class="line">NSData *testData = [testString dataUsingEncoding: NSUTF8StringEncoding];</span><br><span class="line">Byte *iv = (Byte *)[testData bytes];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>dataIn：加解密的数据，<code>const char *</code>类型，使用字符串的<code>UTF8String</code>进行转换</p>
</li>
<li>dataInLength：数据的长度，类型<code>size_t</code></li>
<li>dataOut：输出的数据，加密解密后的数据写在这里，</li>
<li>dataOutAvailable：输出数据时需要的可用空间大小。数据缓冲区的大小（字节）</li>
<li>dataOutMoved：输出数据实际的大小。返回成功后，写入dataOut的字节数。如果由于提供的缓冲区空间不足而返回kCCBufferTooSmall，则在这里返回所需的缓冲区空间。</li>
<li>result：返回的结果<ul>
<li>kCCBufferTooSmall： 指示dataOut缓冲区中不充足的空间。在本例中，*dataOutMoved参数将指示完成操作所需的缓冲区大小。操作可以重试，运行时损失最小。</li>
<li>kCCAlignmentError： 指示数据长度没有正确对齐。这只能对块加密返回，然后只有在解密或加密时禁用填充块时才能返回。</li>
<li>kCCDecodeError   ： 指示格式不正确的密文或“错误的键”错误;仅在解密操作期间发生。</li>
<li>kCCSuccess          = 0,</li>
<li>kCCParamError       = -4300,</li>
<li>kCCMemoryFailure    = -4302,</li>
<li>kCCUnimplemented    = -4305,</li>
<li>kCCOverflow         = -4306,</li>
<li>kCCRNGFailure       = -4307,</li>
<li>kCCUnspecifiedError = -4308,</li>
<li>kCCCallSequenceError= -4309,</li>
<li>kCCKeySizeError </li>
</ul>
</li>
</ul>
<h4 id="CCCrypt调用示例"><a href="#CCCrypt调用示例" class="headerlink" title="CCCrypt调用示例"></a>CCCrypt调用示例</h4><ul>
<li><p>加密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//加密</span><br><span class="line">- (NSString *)encryptUseDES:(NSString *)plainText key:(NSString *)key &#123;</span><br><span class="line">    // 密文</span><br><span class="line">    NSString *ciphertext = nil;</span><br><span class="line">    </span><br><span class="line">    // 加密后的数据</span><br><span class="line">    uint8_t *dataOut = NULL;</span><br><span class="line">    size_t dataOutAvailable = 0;</span><br><span class="line">    size_t dataOutMove = 0;</span><br><span class="line">    </span><br><span class="line">    dataOutAvailable = (plainText.length + kCCBlockSizeDES) &amp; ~(kCCBlockSizeDES - 1);</span><br><span class="line">    dataOut = malloc(dataOutAvailable * sizeof(uint8_t));</span><br><span class="line">    // 将已开辟内存空间buffer的首1个字节的值设为0</span><br><span class="line">    memset((void *)dataOut, 0x0, dataOutAvailable);</span><br><span class="line">    </span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, // 操作名称：加密</span><br><span class="line">                                          kCCAlgorithmDES, // 加密算法</span><br><span class="line">                                          kCCOptionPKCS7Padding | kCCOptionECBMode, // 填充模式，ECB模式</span><br><span class="line">                                          key.UTF8String, // 加密秘钥</span><br><span class="line">                                          kCCKeySizeDES, // 秘钥大小，和加密算法一致</span><br><span class="line">                                          NULL, // 初始向量：ECB模式为空</span><br><span class="line">                                          plainText.UTF8String, // 加密的明文</span><br><span class="line">                                          (size_t)plainText.length, // 加密明文的大小</span><br><span class="line">                                          dataOut, // 密文的接受者</span><br><span class="line">                                          dataOutAvailable, // 预计密文的大小</span><br><span class="line">                                          &amp;dataOutMove); // 加密后密文的实际大小</span><br><span class="line">    if (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        NSData *data = [NSData dataWithBytes:dataOut length:(NSUInteger)dataOutMove];</span><br><span class="line">        // 将data转为16进制字符串</span><br><span class="line">        ciphertext = [self convertDataToHexStr:data];</span><br><span class="line">    &#125;</span><br><span class="line">    return ciphertext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//解密</span><br><span class="line">- (NSString *)decryptUseDES:(NSString*)cipherText key:(NSString*)key &#123;</span><br><span class="line">    // 将16进制转为data</span><br><span class="line">    NSData* cipherData =[self convertHexStrToData:cipherText];</span><br><span class="line">    </span><br><span class="line">    // 解密后的数据</span><br><span class="line">    uint8_t *dataOut = NULL;</span><br><span class="line">    size_t dataOutAvailable = 0;</span><br><span class="line">    size_t dataOutMove = 0;</span><br><span class="line">    </span><br><span class="line">    dataOutAvailable = (cipherData.length + kCCBlockSizeDES) &amp; ~(kCCBlockSizeDES - 1);</span><br><span class="line">    dataOut = malloc(dataOutAvailable * sizeof(uint8_t));</span><br><span class="line">    // 将已开辟内存空间buffer的首1个字节的值设为0</span><br><span class="line">    memset((void *)dataOut, 0x0, dataOutAvailable);</span><br><span class="line">    </span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</span><br><span class="line">                                          kCCAlgorithmDES,</span><br><span class="line">                                          kCCOptionPKCS7Padding | kCCOptionECBMode,</span><br><span class="line">                                          key.UTF8String,</span><br><span class="line">                                          kCCKeySizeDES,</span><br><span class="line">                                          NULL,</span><br><span class="line">                                          cipherData.bytes,</span><br><span class="line">                                          (size_t)cipherData.length,</span><br><span class="line">                                          dataOut,</span><br><span class="line">                                          dataOutAvailable,</span><br><span class="line">                                          &amp;dataOutMove);</span><br><span class="line">    NSString* plainText = nil;</span><br><span class="line">    if (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        NSData* data = [NSData dataWithBytes:dataOut length:(NSUInteger)dataOutMove];</span><br><span class="line">        plainText = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return plainText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>16进制和NSData相互转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//将NSData转成16进制</span><br><span class="line">- (NSString *)convertDataToHexStr:(NSData *)data &#123;</span><br><span class="line">    if (!data || [data length] == 0) &#123;</span><br><span class="line">        return @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableString *string = [[NSMutableString alloc] init];</span><br><span class="line">    </span><br><span class="line">    [data enumerateByteRangesUsingBlock:^(const void *bytes, NSRange byteRange, BOOL *stop) &#123;</span><br><span class="line">        unsigned char *dataBytes = (unsigned char*)bytes;</span><br><span class="line">        for (NSInteger i = 0; i &lt; byteRange.length; i++) &#123;</span><br><span class="line">            NSString *hexStr = [NSString stringWithFormat:@&quot;%02x&quot;, (dataBytes[i]) &amp; 0xff];</span><br><span class="line">            [string appendString:hexStr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将16进制字符串转成NSData</span><br><span class="line">- (NSData *)convertHexStrToData:(NSString *)str &#123;</span><br><span class="line">    if (!str || [str length] == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableData *hexData = [[NSMutableData alloc] init];</span><br><span class="line">    NSRange range;</span><br><span class="line">    if ([str length] % 2 == 0) &#123;</span><br><span class="line">        range = NSMakeRange(0, 2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        range = NSMakeRange(0, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (NSInteger i = range.location; i &lt; [str length]; i += 2) &#123;</span><br><span class="line">        unsigned int anInt;</span><br><span class="line">        NSString *hexCharStr = [str substringWithRange:range];</span><br><span class="line">        // 扫描字符串</span><br><span class="line">        NSScanner *scanner = [[NSScanner alloc] initWithString:hexCharStr];</span><br><span class="line">        [scanner scanHexInt:&amp;anInt];</span><br><span class="line">        </span><br><span class="line">        NSData *entity = [[NSData alloc] initWithBytes:&amp;anInt length:1];</span><br><span class="line">        [hexData appendData:entity];</span><br><span class="line">        </span><br><span class="line">        range.location += range.length;</span><br><span class="line">        range.length = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return hexData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/31/iOS网络层设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adailly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adailly blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/31/iOS网络层设计/" itemprop="url">iOS网络层设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-31T17:11:22+08:00">
                2018-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="网络层设计"><a href="#网络层设计" class="headerlink" title="网络层设计"></a>网络层设计</h2><h3 id="iOS项目架构"><a href="#iOS项目架构" class="headerlink" title="iOS项目架构"></a>iOS项目架构</h3><p>iOS的项目架构我一般设置为三层，即UI层、服务层、数据层，以及第三方依赖层。  </p>
<ul>
<li>UI层：主要管理项目中的所有UI界面，根据模块进行划分，如：登录模块，首页模块，搜索模块等等，还包括通用控件模块。</li>
<li>服务层：基于各模块创建的服务于各模块的服务类，各模块的服务类之间相互独立，如果存在相互调用的情况，就将此抽象出来，设置到数据层中。UI层只负责UI的渲染和交互，数据之间的逻辑交由其对应的服务层处理。</li>
<li>数据层：数据层提供基于整个项目最基础的一些工具，如网络基础工具，数据存取工具等等，一般在服务层中会针对各模块的实际需求进行二次封装和优化。</li>
</ul>
<p>以上，数据层作为最基础的工具被各模块的服务层引用，各模块被对应的UI层应用，服务层之间和UI层之间相互独立，尽量解耦。</p>
<h3 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h3><p>了解了基本的项目架构后，就来详细说说数据层中的网络基础工具层的封装和服务层中网络工具使用，以及项目实际开发过程中遇到的难点及解决方法。</p>
<h3 id="封装基础网络工具"><a href="#封装基础网络工具" class="headerlink" title="封装基础网络工具"></a>封装基础网络工具</h3><p>iOS项目一般都会依赖AFNetworking网络库。<br>基础网络工具一般封装为单例模式，并根据项目需求，提供最基础的网络方法：GET、POST、上传方法(一般为上传图片)，网络监听方法等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;AFNetworking/AFNetworking.h&gt;</span><br><span class="line"></span><br><span class="line">/** 给子类使用的回调 */</span><br><span class="line">typedef void(^netSuccessBlock)(id response);</span><br><span class="line">typedef void(^netFailureBlock)(NSError *error);</span><br><span class="line"></span><br><span class="line">@interface ZORNetworking : NSObject</span><br><span class="line"></span><br><span class="line">/** 成功回调 */</span><br><span class="line">@property (nonatomic, copy) netSuccessBlock netSuccessBlock;</span><br><span class="line">/** 失败回调 */</span><br><span class="line">@property (nonatomic, copy) netFailureBlock netFailureBlock;</span><br><span class="line"></span><br><span class="line">/** 创建单例对象 */</span><br><span class="line">+ (instancetype)shareNetwork;</span><br><span class="line"></span><br><span class="line">/** 销毁单例对象 */</span><br><span class="line">+ (void)destoryNetwork;</span><br><span class="line"></span><br><span class="line">/** 添加请求头 */</span><br><span class="line">- (void)addHeaderWithToken:(NSString *)token;</span><br><span class="line"></span><br><span class="line">/** 监听网络状态 */</span><br><span class="line">- (void)startMonitoringNetworkStatus;</span><br><span class="line"></span><br><span class="line">/** 通知监听网络状态 */</span><br><span class="line">- (void)stopMonitoringNetworkStatus;</span><br><span class="line"></span><br><span class="line">/** GET方法 */</span><br><span class="line">- (void)GET:(NSString *)URLString parameters:(id)parameters success:(void (^)(NSURLSessionDataTask *task, id responseObject))success</span><br><span class="line">    failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure;</span><br><span class="line"></span><br><span class="line">/** POST方法 */</span><br><span class="line">- (void)POST:(NSString *)URLString parameters:(id)parameters success:(void (^)(NSURLSessionDataTask *task, id responseObject))success</span><br><span class="line">    failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="BaseUrl设置"><a href="#BaseUrl设置" class="headerlink" title="BaseUrl设置"></a>BaseUrl设置</h4><p>网络请求工具中只要切换BaseURL就能自由访问不同的服务器，AFN提供了创建BaseURL的方法，在创建单例的时候自由创建。<br>初始化设置的时候根据后台的设置，进行AFN请求数据格式和接受数据格式的设置，AFN提供了两个类进行设置，<code>self.manager.requestSerializer = [AFHTTPRequestSerializer serializer];</code>, <code>self.manager.responseSerializer = [AFHTTPResponseSerializer serializer];</code><br>具体参考<code>AFHTTPResponseSerializer</code>, <code>AFHTTPRequestSerializer</code>这两个类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)shareNetwork &#123;</span><br><span class="line">    static ZORNetworking *network = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        network = [[ZORNetworking alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return network;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化方法</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:BASE_URL]];</span><br><span class="line">        /** 请求设置 */</span><br><span class="line">        // 超时时间</span><br><span class="line">        self.manager.requestSerializer.timeoutInterval = 45.0;</span><br><span class="line">        </span><br><span class="line">        /** 接收设置 */</span><br><span class="line">        // 返回值格式设置</span><br><span class="line">        self.manager.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">        self.manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, @&quot;text/html&quot;, nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提供销毁单例的方法"><a href="#提供销毁单例的方法" class="headerlink" title="提供销毁单例的方法"></a>提供销毁单例的方法</h4><p>提供销毁单例的方法是因为，想在登录的时候自由切换请求的IP地址，即BaseURL，退出登录后重新登录网络请求的单例类仍然存在，并不会重新创建，所以无法在不进行<code>commond+R</code>的情况下自由切换。<br>提供销毁单例的方法后，就可以自由的切换BaseURL，切换后再次调用网络方法，将会创建一个新的网络单例类。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 将静态变量设置为全局可访问</span><br><span class="line">static ZORNetworking *network = nil;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line"></span><br><span class="line">@implementation ZORNetworking</span><br><span class="line"></span><br><span class="line">+ (instancetype)shareNetwork &#123;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        network = [[ZORNetworking alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return network;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)destoryNetwork &#123;</span><br><span class="line">	// dispatch_once_t 为 long 类型</span><br><span class="line">    onceToken = 0l;</span><br><span class="line">    network = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="创建基础的请求方法"><a href="#创建基础的请求方法" class="headerlink" title="创建基础的请求方法"></a>创建基础的请求方法</h4><p>以上基础设置完成后，就可以创建基础的请求方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)GET:(NSString *)URLString parameters:(id)parameters success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure &#123;</span><br><span class="line">    [self.manager GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            success(task, responseObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">            failure(task, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)POST:(NSString *)URLString parameters:(id)parameters success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure &#123;</span><br><span class="line">    [self.manager POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            success(task, responseObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">            failure(task, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="网络监控方法的创建和调用"><a href="#网络监控方法的创建和调用" class="headerlink" title="网络监控方法的创建和调用"></a>网络监控方法的创建和调用</h4><p>AFN提供了监控网络状态的方法，可以直接调用使用，为了实时获取网络的状态，一般在APP的启动方法里调用，但是如果网络状态的枚举类型定义在了网络工具单例类中，并定义相关的枚举属性，虽然可以实时监测到，但是通过状态属性并不能实时获取到。需要创建新的网络状态的单例类来获取，在需要检测网络状态的地方调用即可。<br>检测网络状态方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)startMonitoringNetworkStatus &#123;</span><br><span class="line">    [[self.manager reachabilityManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        switch (status) &#123;</span><br><span class="line">            case AFNetworkReachabilityStatusReachableViaWiFi: &#123;</span><br><span class="line">                [ZORNetworkStatus shareNetStatus].networkStatus = NetworkStatusViaWiFi;</span><br><span class="line">                DLog(@&quot;wifi&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case AFNetworkReachabilityStatusReachableViaWWAN: &#123;</span><br><span class="line">                [ZORNetworkStatus shareNetStatus].networkStatus = NetworkStatusViaWWAN;</span><br><span class="line">                DLog(@&quot;移动网络&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case AFNetworkReachabilityStatusNotReachable: &#123;</span><br><span class="line">                [ZORNetworkStatus shareNetStatus].networkStatus = NetworkStatusNotReachable;</span><br><span class="line">                DLog(@&quot;无网络&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case AFNetworkReachabilityStatusUnknown: &#123;</span><br><span class="line">                [ZORNetworkStatus shareNetStatus].networkStatus = NetworkStatusUnKnown;</span><br><span class="line">                DLog(@&quot;未知网络&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [[self.manager reachabilityManager] startMonitoring];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="网络服务层"><a href="#网络服务层" class="headerlink" title="网络服务层"></a>网络服务层</h3><p>通过继承或分类创建进一步解析后的网络服务层，在这层中根据返回的结果设置自定义的提示内容，如加载动画，加载完成提示，网络不佳提示，无数据提示，错误提示等等。</p>
<h4 id="基础服务"><a href="#基础服务" class="headerlink" title="基础服务"></a>基础服务</h4><p>创建基础网络服务，通过继承或分类进行创建，根据产品的设计，进行不同情况的一系列提示。<br>其中NSError为自定义的error<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (void)POST:(NSString *)URL params:(id)params success:(void (^)(id))success failure:(void (^)(NSError *))failure &#123;</span><br><span class="line">	// 加载动画设置</span><br><span class="line">	// code</span><br><span class="line"></span><br><span class="line">    [self POST:URL parameters:params success:^(NSURLSessionDataTask *task, id responseObject) &#123;</span><br><span class="line">    	// 隐藏加载动画</span><br><span class="line">    	// code</span><br><span class="line"></span><br><span class="line">    	// 根据后台的通用数据结构，解析返回结果，</span><br><span class="line">        NSDictionary *response = responseObject;</span><br><span class="line">        </span><br><span class="line">        // 结果中可能带有code和message，解析后进行不同的UI设置</span><br><span class="line"></span><br><span class="line">        // code解析</span><br><span class="line">        NSInteger ok = [response[@&quot;code&quot;] integerValue];</span><br><span class="line">        // 获取后台返回的消息</span><br><span class="line">        NSString *msg = response[@&quot;message&quot;];</span><br><span class="line"></span><br><span class="line">        if (成功) &#123; // 有数据</span><br><span class="line">        	// 解析出数据后返回，一般为json字符串</span><br><span class="line">        	// code</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                success(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; // 失败</span><br><span class="line">        	// 不同失败结果的UI设置</span><br><span class="line">        	// 无数据设置等等</span><br><span class="line">        	// code</span><br><span class="line"></span><br><span class="line">            if (failure) &#123;</span><br><span class="line">            	// 自定义error对象并回调</span><br><span class="line">                NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NetErrorTypeBackData userInfo:@&#123;NSLocalizedDescriptionKey : msg&#125;];</span><br><span class="line">                failure(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123;</span><br><span class="line">    	// 隐藏加载动画</span><br><span class="line">    	// code</span><br><span class="line"></span><br><span class="line">    	// 解析error</span><br><span class="line">    	// 根据error的code，和后台的说明进行设置</span><br><span class="line">    	// 1、请求失败设置</span><br><span class="line">    	// code</span><br><span class="line"></span><br><span class="line">    	// 2、请求超时设置</span><br><span class="line">    	// code</span><br><span class="line"></span><br><span class="line">    	...</span><br><span class="line">    	// 返回的error，可以直接返回，也可以进行自定义后返回</span><br><span class="line">    	// code</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            if (failure) &#123;</span><br><span class="line">                failure(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="各模块的网络服务层"><a href="#各模块的网络服务层" class="headerlink" title="各模块的网络服务层"></a>各模块的网络服务层</h4><p>针对不同的模块，创建不同模块的网络服务层，通过分类创建。<br>给模块中所有需要用到网络请求的action都创建一个对应的方法，方便区分和维护。<br>在这一层中，尽量将网络请求的URL、参数包装、解析后的数据等操作都进行处理，UI层只管调用方法，调用成功后直接拿到需要的数据进行UI的渲染。<br>通过这种设计最大程度的对ViewController进行瘦身。 </p>
<h3 id="AFN单独传递字符串参数的设置"><a href="#AFN单独传递字符串参数的设置" class="headerlink" title="AFN单独传递字符串参数的设置"></a>AFN单独传递字符串参数的设置</h3><p>项目中用到DES加密，后台要求将加密后的字符串密文直接传递过去，在以往的经验中，所有的参数都是通过NSDictionary进行传递的。直接改变参数为字符串传递，返回错误的结果。<br>结果调试，后台一直报的错误是格式错误。<br>经过查找资料，和对HTTP请求的理解有关，AFN默认的请求是键值形式的字符串，即application/x-www-form-urlencoded。<br>AFN内部会将接收到的参数自动按照键值的形式进行组织后传递，所有会看到错误为:<code>input string &#39;=%&#39;</code> ，类似这种错误。<br>遇到这种问题可以尝试下面两种方法进行解决。</p>
<ul>
<li>解决方法1<br>传递的参数为纯文本形式的字符串，设置请求头为<code>[self.manager.requestSerializer setValue:@&quot;text/plain&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</code>。</li>
</ul>
<ul>
<li>解决方法2<br>AFN提供了<code>requestSerializer</code>的扩展方法，直接创建一个自定义的<code>requestSerializer</code>，就不需要通过<code>init</code>创建<code>requestSerializer</code>了，AFN就不会将参数按照键值的形式传递了。<br>也有可能还需要设置请求头，具体根据后台进行设置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 自定义requestSerializer</span><br><span class="line">[self.manager.requestSerializer setQueryStringSerializationWithBlock:^NSString * _Nonnull(NSURLRequest * _Nonnull request, id  _Nonnull parameters, NSError * _Nullable __autoreleasing * _Nullable error) &#123;</span><br><span class="line">            return parameters;</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/28/RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adailly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adailly blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/RunLoop/" itemprop="url">RunLoop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T12:19:09+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>RunLoop的基本概念在这里不做介绍，网上的资料有很多。</p>
<h4 id="线程和RunLoop"><a href="#线程和RunLoop" class="headerlink" title="线程和RunLoop"></a>线程和RunLoop</h4><p>一个线程对应一个RunLoop，主线程的RunLoop在程序运行时时默认打开的。在子线程中的RunLoop如果不主动获取，那么它就不会产生。<br>RunLoop的创建时在第一次获取时，RunLoop的销毁是在线程结束。你只能在一个线程内部获取其RunLoop。</p>
<h4 id="获取并启动RunLoop"><a href="#获取并启动RunLoop" class="headerlink" title="获取并启动RunLoop"></a>获取并启动RunLoop</h4><ul>
<li><p>Foundation框架下：<br>获取当前线程的RunLoop：<code>self.runLoop = [NSRunLoop currentRunLoop];</code><br>启动线程：<code>[self.runLoop run]</code><br>退出线程：关闭timer或移除port。</p>
</li>
<li><p>CoreFoundation框架下：<br><code>@property (nonatomic, assign) CFRunLoopRef runloop;</code><br>获取当前线程：<code>self.runloop = CFRunLoopGetCurrent();</code><br>启动线程：<code>CFRunLoopRun();</code><br>退出线程：<code>CFRunLoopStop(self.runloop)</code></p>
</li>
</ul>
<h4 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h4><p>我们都知道，RunLoop是通过不断的循环来执行事件的，执行的事件有两种类型，一种的timer，一种是source。<br>使用NSTimer的时候，我们都习惯的将NSTimer添加到当前的RunLoop中，一般是在主线程中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timeRunLoopAction) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure></p>
<p>这时currentRunLoop会一直循环执行，知道我们把timer关闭后，RunLoop因没有timer而退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.timer invalidate];</span><br><span class="line">self.timer = nil;</span><br></pre></td></tr></table></figure>
<h4 id="常驻线程"><a href="#常驻线程" class="headerlink" title="常驻线程"></a>常驻线程</h4><p>如果我们需要开辟的子线程一直在后台运行，如在后台上传用户的相关数据，就需要开启当前线程的RunLoop。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/22/CocoaPods安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adailly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adailly blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/CocoaPods安装/" itemprop="url">CocoaPods安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T12:23:45+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="CocoaPods安装"><a href="#CocoaPods安装" class="headerlink" title="CocoaPods安装"></a>CocoaPods安装</h3><h4 id="检查及安装rvm"><a href="#检查及安装rvm" class="headerlink" title="检查及安装rvm"></a>检查及安装rvm</h4><p>指令：<code>rvm -v</code>，如没有进行安装<code>rvm</code>。</p>
<ul>
<li>安装rvm：<code>curl -L get.rvm.io | bash -s stable</code></li>
<li>指定源：<code>source ~/.rvm/scripts/rvm</code></li>
<li>查看是否安装成功：<code>rvm -v</code></li>
<li>列出指定源里面ruby的版本：<code>rvm list known</code></li>
</ul>
<h4 id="安装ruby"><a href="#安装ruby" class="headerlink" title="安装ruby"></a>安装ruby</h4><p>在上一步中找出最新的ruby的版本。</p>
<ul>
<li>安装ruby：<code>rvm install 2.4.1</code>，根据提示按<code>enter</code>键即可，2.4.1是当前的最新版本。</li>
<li>检查是否安装成功：<code>rvm list</code></li>
</ul>
<h4 id="检查更新RubyGems"><a href="#检查更新RubyGems" class="headerlink" title="检查更新RubyGems"></a>检查更新RubyGems</h4><p>RubyGems是一个方便而强大的Ruby程序包管理器，Ruby的第三方插件是用gem方式来管理的，非常容易发布和共享，一个简单的命令就可以安装上第三方的扩展库。</p>
<ul>
<li>查看RubyGems的版本：<code>gem -v</code></li>
<li>更换源：<code>gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</code><br>因为墙的存在，需要更换Ruby的软件源<code>rubygems.org</code>，之前国内使用的 <code>https://ruby.taobao.org</code>，不再建议使用的了，这是因为 <code>taobao Gems</code> 源已停止维护，现由 <code>ruby-china</code> 提供镜像服务。  </li>
<li>查看源路径是否替换成功：<code>gem sources -l</code><br>确保只有 <code>gems.ruby-china.org</code></li>
<li>更新到最新版本：<code>gem update --system</code></li>
<li>查看版本：<code>gem --version</code></li>
</ul>
<h4 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h4><ul>
<li><p>安装指令：<code>sudo gem install cocoapods</code><br>OS X 10.11之前系统的安装cocoapods 指令： <code>sudo gem install cocoapods</code><br>OS X 10.11以后系统的安装cocoapods 指令： <code>sudo gem install -n /usr/local/bin cocoa pods</code></p>
</li>
<li><p>如果安装了多个Xcode使用下面的命令选择（最好选择最近的Xcode版本）<br><code>sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer</code></p>
</li>
<li>同步CocoaPods：<code>pod setup</code>  这一步需要等待很长的时间，更新完毕就可以使用了。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/22/iOS面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adailly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adailly blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/iOS面试/" itemprop="url">iOS面试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T11:28:28+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="iOS面试"><a href="#iOS面试" class="headerlink" title="iOS面试"></a>iOS面试</h2><p>进入2018.3后开始了一波面试，现就总结下遇到的公司和面试的经验。<br>离开上一家公司</p>
<h3 id="非技术问题"><a href="#非技术问题" class="headerlink" title="非技术问题"></a>非技术问题</h3><h4 id="介绍自己"><a href="#介绍自己" class="headerlink" title="介绍自己"></a>介绍自己</h4><ul>
<li>介绍自己</li>
<li>谈下项目经验</li>
</ul>
<h4 id="评价上一家公司"><a href="#评价上一家公司" class="headerlink" title="评价上一家公司"></a>评价上一家公司</h4><ul>
<li>为什么离职</li>
<li>离职原因</li>
</ul>
<h4 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h4><ul>
<li>看重什么样的公司</li>
<li>对公司有什么要求</li>
<li>对今后有什么规划</li>
</ul>
<h4 id="公司可能面临的问题"><a href="#公司可能面临的问题" class="headerlink" title="公司可能面临的问题"></a>公司可能面临的问题</h4><ul>
<li>怎么看待加班</li>
<li>设定一个场景问你怎么做<br>  比如一个人开发能胜任吗，工作中遇到问题怎么解决，就是说你可能没有同事进行交流，也没有技术大牛对你进行指导。</li>
</ul>
<h3 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h3><h4 id="基础技术问题"><a href="#基础技术问题" class="headerlink" title="基础技术问题"></a>基础技术问题</h4><p>一般有工作年限的基本技术都会掌握</p>
<h4 id="简历中罗列的技术点对你进行提问"><a href="#简历中罗列的技术点对你进行提问" class="headerlink" title="简历中罗列的技术点对你进行提问"></a>简历中罗列的技术点对你进行提问</h4><h4 id="常用第三方及原理"><a href="#常用第三方及原理" class="headerlink" title="常用第三方及原理"></a>常用第三方及原理</h4><p>用过哪些第三方，说说原理。</p>
<h4 id="复杂问题的综合考虑"><a href="#复杂问题的综合考虑" class="headerlink" title="复杂问题的综合考虑"></a>复杂问题的综合考虑</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/21/教育/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adailly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adailly blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/教育/" itemprop="url">教育</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-21T18:30:05+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="青少年常见心理问题与对策-李玫瑾教授讲座笔记"><a href="#青少年常见心理问题与对策-李玫瑾教授讲座笔记" class="headerlink" title="青少年常见心理问题与对策  - 李玫瑾教授讲座笔记"></a>青少年常见心理问题与对策  - 李玫瑾教授讲座笔记</h3><p>这个讲座的视频时间有2.5小时，听了非常受用。在即将打算抚育小孩之前学习育儿之道，对孩子观念、性格的塑造以及和父母的关系都有很大的帮助。<br>以下是李教授从事心理犯罪研究的几点总结：</p>
<h4 id="未成年人的问题是成年人造成的"><a href="#未成年人的问题是成年人造成的" class="headerlink" title="未成年人的问题是成年人造成的"></a>未成年人的问题是成年人造成的</h4><p>孩子的每种心理或行为问题，都与父母的抚育方式有关。<br>举个例子：孩子出生后1到1岁半之前的抚育非常重要，这期间孩子由谁抚育，谁就具有孩子一生的控制力。所以我们经常会看到或听到这个孩子不听父母的话，只听他奶奶或姥姥的，这就是因为这个阶段父母没有抚育的原因，或者说是因为没有长期抚育。</p>
<h4 id="未成年人的问题是滞后反应"><a href="#未成年人的问题是滞后反应" class="headerlink" title="未成年人的问题是滞后反应"></a>未成年人的问题是滞后反应</h4><h5 id="12岁后发生的问题，源由在12岁之前。"><a href="#12岁后发生的问题，源由在12岁之前。" class="headerlink" title="12岁后发生的问题，源由在12岁之前。"></a>12岁后发生的问题，源由在12岁之前。</h5><p>这是因为12岁之前孩子是弱小的，他还不能明显的按照自己的意愿去做一些事情，所以这个阶段不容易看出问题。</p>
<h5 id="等我们有教育经验时，我们就没有机会了"><a href="#等我们有教育经验时，我们就没有机会了" class="headerlink" title="等我们有教育经验时，我们就没有机会了"></a>等我们有教育经验时，我们就没有机会了</h5><p>等我们学习到了经验，孩子就长大了，错过了孩子观念和性格形成的关键时期，就很难改变孩子的行为了。</p>
<h4 id="心理发展有关键期"><a href="#心理发展有关键期" class="headerlink" title="心理发展有关键期"></a>心理发展有关键期</h4><p>做好父母，也需要耐心与智慧。我们需要时刻观察孩子成长的阶段，并在各个阶段调整自己的教育方式。尤其是在成长的关键阶段，如14岁，16岁，18岁等。</p>
<h4 id="心理成长和发展的时期分类"><a href="#心理成长和发展的时期分类" class="headerlink" title="心理成长和发展的时期分类"></a>心理成长和发展的时期分类</h4><table>
<thead>
<tr>
<th>年龄</th>
<th>阶段</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-1</td>
<td>乳儿期</td>
</tr>
<tr>
<td>2-3</td>
<td>婴儿期</td>
</tr>
<tr>
<td>4-5</td>
<td>幼儿期</td>
</tr>
<tr>
<td>6-11</td>
<td>学龄初期</td>
</tr>
<tr>
<td>12-15</td>
<td>少年期</td>
</tr>
<tr>
<td>16-18</td>
<td>青年初期</td>
</tr>
<tr>
<td>19-25</td>
<td>青年中期</td>
</tr>
<tr>
<td>26-35</td>
<td>青年后期</td>
</tr>
<tr>
<td>36-60</td>
<td>中年期</td>
</tr>
<tr>
<td>60以上</td>
<td>老年期</td>
</tr>
</tbody>
</table>
<p>18岁之前，是孩子观念、性格塑造的关键时期，这期间孩子会经历：情感发展、言语发展、社会性发展、认知、观念、性格、自我意识、独立性。<br>18岁之后，孩子的观念、性格、人格趋于稳定，如果前期没有培养好，这个阶段就很难矫正了。</p>
<h4 id="情感发展"><a href="#情感发展" class="headerlink" title="情感发展"></a>情感发展</h4><p>半岁出现的心理反应：认人，依恋<br>人与人之间的关系：需要、情感<br>情感是诸多心理发展的基础。<br>父母由此获得抚养孩子的心理资本，一岁半之前谁带孩子谁获得孩子的心理资本，谁具有孩子的控制力。</p>
<h4 id="言语发展"><a href="#言语发展" class="headerlink" title="言语发展"></a>言语发展</h4><p>爱的抚养，一定是唠叨，一定是有亲人在身旁的抚养，听的多了自然话就多了。</p>
<h4 id="社会性发展"><a href="#社会性发展" class="headerlink" title="社会性发展"></a>社会性发展</h4><p>言语发展和社会性发展息息相关，社会性主要指爱不爱和人交流。</p>
<h4 id="认知、观念、性格"><a href="#认知、观念、性格" class="headerlink" title="认知、观念、性格"></a>认知、观念、性格</h4><p>12岁之前培养。<br>观念：看到了就形成了。<br>信念：明白了并坚持。</p>
<p>观念：来自父母的唠叨，父母的影响，父母的教育。<br>性格：与别人的有关的行为，就是社会行为，就是性格。一个人和别人有关的行为方式，就是性格。</p>
<h3 id="6岁之前塑造青少年，防止出现问题"><a href="#6岁之前塑造青少年，防止出现问题" class="headerlink" title="6岁之前塑造青少年，防止出现问题"></a>6岁之前塑造青少年，防止出现问题</h3><p>克制任性、防止压抑、学会控制、学会忍耐、防止自私、经历挫折</p>
<h4 id="克制任性"><a href="#克制任性" class="headerlink" title="克制任性"></a>克制任性</h4><p>一定要说不。<br>四个不要的训练：不要骂他，不要打他，不要说教，不要走开。</p>
<h4 id="学会控制"><a href="#学会控制" class="headerlink" title="学会控制"></a>学会控制</h4><p>通过诱惑的方式，让其学会控制自己。</p>
<h4 id="学会忍耐"><a href="#学会忍耐" class="headerlink" title="学会忍耐"></a>学会忍耐</h4><p>吃饭的忍耐和控制。</p>
<h4 id="防止自私"><a href="#防止自私" class="headerlink" title="防止自私"></a>防止自私</h4><p>管理别人，吃饭立规矩。</p>
<h4 id="经历挫折"><a href="#经历挫折" class="headerlink" title="经历挫折"></a>经历挫折</h4><p>体能训练，如学游泳。</p>
<h3 id="青春期的教育"><a href="#青春期的教育" class="headerlink" title="青春期的教育"></a>青春期的教育</h3><p>早期教育缺陷的补救期。</p>
<h4 id="青春期引起的变化"><a href="#青春期引起的变化" class="headerlink" title="青春期引起的变化"></a>青春期引起的变化</h4><p>生理：身高、生理变化<br>心理：<br>身高引起的心理变化：自己的事情自己做，独立意识增强，自尊性增强。少唠叨。<br>没新意导致逆反<br>改变教育的方式：点到为止，不要坚持太长时间。</p>
<h4 id="成瘾问题"><a href="#成瘾问题" class="headerlink" title="成瘾问题"></a>成瘾问题</h4><p>内向会导致不愿意发展其社会性。<br>内向的改变：交朋友，拔出来。培养多兴趣。<br>成瘾是因为：感觉单一，人会痴迷。<br>解决成瘾问题：<br>对孩子的兴趣表示肯定，与他共同发展，和他有共同的语言。</p>
<h4 id="性教育"><a href="#性教育" class="headerlink" title="性教育"></a>性教育</h4><p>初中：性的魅力<br>高中：人类性史话。</p>
<h4 id="生命的教育"><a href="#生命的教育" class="headerlink" title="生命的教育"></a>生命的教育</h4><p>如何宝贵生命：</p>
<ul>
<li>健康 </li>
<li>自由，守法才能享受自由</li>
<li>情义</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/HelloWord/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adailly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adailly blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/HelloWord/" itemprop="url">Hello Hexo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T21:41:47+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h4><p>一直想做个自己的博客，很久以前做过一个基础版的，后面不知道什么原因就不了了之了。<br>现在有空，就抓紧时间自己做一个了。<br>主要是配置文件的问题，如下是一些常用的命令，记录于此方便查看使用。</p>
<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo文档</a><br><a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">Next主题文档</a></p>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><ul>
<li>前提：已安装node、Git</li>
<li>利用node安装Hexo：<code>npm install -g Hexo-cli</code></li>
<li>如果npm安装速度较慢或失败，建议把npm改为<a href="https://npm.taobao.org" target="_blank" rel="noopener">cnpm</a></li>
</ul>
<h4 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h4><ul>
<li><code>$ hexo init &lt;folder&gt;</code>，<code>floder</code>为自定义的项目名称</li>
<li><code>$ cd &lt;folder&gt;</code>，打开项目</li>
<li><code>$ npm/cnpm init</code>，执行<code>init</code>操作</li>
<li>配置 _config.yml，配置相关文件</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>新建文章：<code>$ hexo new [layout] &lt;title&gt;</code>,如果没有设置 <code>layout</code> 的话，默认使用 _config.yml 中的 <code>default_layout</code> 参数代替。<code>title</code>：文章名称</li>
<li>生成静态文件：<code>$ hexo generate</code><ul>
<li>该命令有两个选项：</li>
<li><code>-d</code>: deploy 文件生成后立即部署网站</li>
<li><code>-w</code>: watch    监视文件变动  </li>
<li>简写： <code>$ hexo g (选项)</code></li>
</ul>
</li>
<li>发表草稿：<code>$ hexo publish [layout] &lt;filename&gt;</code></li>
<li>启动服务器：<code>$ hexo server</code><ul>
<li>该命令有三个选项：</li>
<li><code>-p</code>: port     重设端口</li>
<li><code>-s</code>: static 只使用静态文件</li>
<li><code>-l</code>: log     启动日记记录，使用覆盖记录格式</li>
<li>简写: <code>$ hexo s</code></li>
</ul>
</li>
<li>部署网站：<code>$ hexo deploy</code><ul>
<li>该命令有一个选项</li>
<li><code>-g</code>: generate    部署之前预先生成静态文件</li>
<li>简写：<code>$ hexo d</code></li>
</ul>
</li>
<li><p>清楚缓存：<code>$ hexo clean</code></p>
</li>
<li><p>使用sh命令一键部署：执行命令<code>sh ~/hexod.sh</code></p>
</li>
<li>命令的编写：<ul>
<li>进入到<code>~</code>目录</li>
<li>使用<code>vim hexod.sh</code>编写命令</li>
<li>命令内容：<code>hexo clean &amp;&amp; hexo g -d</code></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">adailly</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">adailly</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
